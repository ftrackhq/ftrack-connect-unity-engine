import logging
import os
import sys
import tempfile
import threading
import time
import traceback

# Wait until coverage has started to import these modules
# Otherwise circular imports will import unity_client and coverage will be 
# affected
if __name__ == '__main__': # pragma: no cover
    pass
else:
    import polling_server
    import unity_client_service

###### Project settings
# In the future these should be set in the Unity editor and passed to the client somehow (environment, command-line, etc)

# What port do we use for communication? Make sure to also update unity_server.py

client_port = 18862


######### Coverage, used for testing #########
# Set WANT_UNITY_PYTHON_COVERAGE to enable coverage

_want_coverage = os.environ.has_key('WANT_UNITY_PYTHON_COVERAGE')
_coverage_object = None
_coverage_directory = None

if _want_coverage:
    import coverage
######### Coverage, used for testing #########

_terminate = False

# Enables logging to a file, contains the log full file path
# TODO: use the logging module, create a Handler to send it upstream.
_log_to_file = os.environ.get('UNITY_PYTHON_CLIENT_LOGFILE')
_log_to_console = os.environ.get('UNITY_PYTHON_CLIENT_LOG_TO_SERVER')

def _do_log(msg, loglevel):
    message = '[UnityClient] {}\n'.format(msg)
    if _log_to_file:
        with open(_log_to_file, 'a') as f:
            f.write(message)

    if _log_to_console or (loglevel >= logging.WARNING):
        try:
            import unity_connection
            UnityEngine = unity_connection.get_module('UnityEngine')
            if loglevel >= logging.ERROR:
                UnityEngine.Debug.LogError(message)
            elif loglevel >= logging.WARNING:
                UnityEngine.Debug.LogWarning(message)
            elif _log_to_console:
                UnityEngine.Debug.Log(message)
        except Exception, e:
            print("Not logging to Unity because: {}".format(e))
            pass

    print(message)

def log(msg):
    _do_log(msg, logging.INFO)

def error(msg):
    _do_log(msg, logging.ERROR)

def exception(msg, xcp):
    tb = traceback.format_exc()
    _do_log(msg + "\n" + tb, logging.ERROR)

log("sys.executable = " + sys.executable)
log("sys.version = " + sys.version)
log("sys.path = " + '\n\t'.join(sys.path))
    
class UnityClient():
    """
    UnityClient is a rpyc server, responsible for remote calls coming from Unity
    It uses a default rpyc service that extends the rpyc slave service

    The UnityClient can be initialized with a client init module. Client init 
    modules can:
        - Override the rpyc service that is used by the UnityClient
        - Install an idle callback
    
    client_init_module_path: path to a Python module containing a global 
    function having the following signature:
        def on_init_client(client):
    """
    def __init__(self, client_init_module_path = None):
        # The rpyc service to use
        self._service = unity_client_service.UnityClientService
        
        # An callback to call on idle
        self._idle_callback = None
        
        # Here we are fully initialized. Call the client init module if 
        # required
        if client_init_module_path:
            try:
                import imp
                log('Loading client init module (%s)'%client_init_module_path)
                client_init_module = imp.load_source('client_init_module', client_init_module_path)
                client_init_module.on_init_client(self)
            except Exception as e:
                exception('Got exception while trying to load client init module', e)

                # Exceptions in client init modules should abort the client 
                # process
                raise e

        # This global variable tells us when to terminate. 
        # We need to set the global variable of the module since this class is 
        # instantiated from the __main__ module
        global _terminate
        _terminate = False 
        
    def register_idle_callback(self, idle_callback):
        """
        Called by the client init module to register an idle callback
        
        idle_callback: the callback to invoke on idle. The idle callback's 
        signature does not accept any argument.
        """
        self._idle_callback = idle_callback
        
    def register_service(self, service):
        """
        Called by the client init module to register a custom rpyc service

        service: A rpyc service. In order to work with the polling server, the 
                 service class must derive from unity_client_service.UnityClientService
        """
        assert issubclass(service, unity_client_service.UnityClientService)
        self._service = service

    def run(self):
        """
        The UnityClient main thread loop:
        - Dispatches data coming from the polling server if any
        - Invokes the client init module idle callback if any
        - Wait for at most 1 millisecond
        - Repeat
        """
        try:
            polling_server.PollingServerUtil.init()
    
            rpyc_client = polling_server.PollingServer(self._service, port=client_port)
            rpyc_client_thread = threading.Thread(target = rpyc_client.start, name = "Unity Client Thread")
            rpyc_client_thread.start()
            
            last_time = time.time()
            log('Entering client loop')
            
            # Use the global variable from the module, not from __main__
            global _terminate
            while not _terminate:
                # Dispatches data coming from the polling server if any
                polling_server.PollingServerUtil.dispatch_data()

                # Invokes the client init module idle callback if any
                if self._idle_callback:
                    self._idle_callback()
                    
                # Wait for at most 1 millisecond
                curr_time = time.time()
                elapsed = curr_time - last_time
                if (elapsed < 0.001):
                    time.sleep(0.001 - elapsed)
                    
                last_time = curr_time
                
            log('Terminating client connection')
            polling_server.PollingServerUtil.close()
            rpyc_client.close()

        except Exception, e:
            exception('Exception in client loop', e)
            
def terminate():
    global _terminate
    _terminate = True
    
def start():
    # Import the module, otherwise we are working in the main module and 
    #accessing globals is tricky. Also, coverage will work for the module globals 
    import unity_client
    
    client_init_module_path = sys.argv[1] if len(sys.argv) > 1 else None
    log('client_init_module_path = {}'.format(client_init_module_path))
    client = unity_client.UnityClient(client_init_module_path)
    client.run()
               
if __name__ == "__main__": # pragma: no cover
    """
    The Unity Client entry point. Simply execute the script to get a default 
    UnityClient, or pass a client init module path to customize the Unity 
    Client behavior (see UnityClient.__init__
    """
    if _want_coverage:
        _coverage_directory = tempfile.mkdtemp(suffix='-client_coverage')
        log('Coverage results will be located in {} when the client terminates'.format(_coverage_directory))
        
        # Use the temp folder name in the coverage file name to make it unique
        coverage_file_name = os.path.split(_coverage_directory)[-1]

        _coverage_object = coverage.Coverage(data_file=os.path.join(_coverage_directory,coverage_file_name))
        _coverage_object.start()

    try:
        start()
    except Exception, e:
        exception('Client caught an exception', e)

    if _want_coverage:
        _coverage_object.stop()
        _coverage_object.save()
        
        log('Writing coverage results, this could take a moment')
        _coverage_object.html_report(directory=_coverage_directory, ignore_errors=True)

    log("The Unity Client process is terminating")
