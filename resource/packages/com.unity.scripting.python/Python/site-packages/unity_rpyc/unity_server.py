import os
import sys
import subprocess
import System.IO
import threading
import time
import traceback
import UnityEditor
import UnityEngine

###### Project settings
# These are normally set by the PythonRunner

# Where is the python executable to use to spawn the client?
# Set by the PythonRunner.
python_executable = sys.executable

# What additional site-packages should we tell the server about?
# We always tell the server about the current site-packages; this option is
# if you've got e.g. studio scripts.
extra_site_packages = []

# What port do we use for communication *to* the client?
# The client also needs to know this.
client_port = 18862

# What port do we use for communication *from* the client?
# The client also needs to know this.
polling_port = 18861

"""
Logging
"""
def log(msg):
    UnityEngine.Debug.Log('[UnityServer] ' + msg)

def error(msg):
    UnityEngine.Debug.LogError('[UnityServer] ' + msg)

def exception(msg):
    """
    Print the last exception thrown along with the message.
    """
    tb = traceback.format_exc()
    UnityEngine.Debug.LogError('[UnityServer] {}\n{}'.format(msg, tb))

try:
    import rpyc
    try:
        import polling_server
    except ImportError:
        import unity_rpyc.polling_server as polling_server
except Exception as e:
    exception("Could not start the Python server (missing rpyc Python package). Please refer to the com.unity.scripting.python documentation on how to configure Python for Unity")
    raise e

"""
Coverage
"""
# Set WANT_UNITY_PYTHON_COVERAGE to enable coverage
import os
import tempfile

_want_coverage = os.environ.has_key('WANT_UNITY_PYTHON_COVERAGE')
_coverage_object = None
_coverage_directory = None

if _want_coverage:
    import coverage

"""
Public interface. Unity scripts should only be calling these functions
"""
def start(client_init_module_path = None):
    """ 
    Starts the Unity rpyc server
    """
    global _want_coverage

    log('In on_init_client')

    if _want_coverage:
        global _coverage_object
        global _coverage_directory
        _coverage_directory = tempfile.mkdtemp(suffix='-server_coverage')
        log('Coverage results will be located in {} when the server terminates'.format(_coverage_directory))
        
        # Use the temp folder name in the coverage file name to make it unique
        coverage_file_name = os.path.split(_coverage_directory)[-1]
        _coverage_object = coverage.Coverage(data_file=os.path.join(_coverage_directory,coverage_file_name))
        _coverage_object.start()
    
    UnityServer.start(client_init_module_path)

def stop(terminate_client = False):
    """ 
    Stops the Unity rpyc server, and the client if requested
    """
    UnityServer.stop(terminate_client)

    if _want_coverage:
        global _coverage_object
        global _coverage_directory
        
        if _coverage_object:
            _coverage_object.stop()
            _coverage_object.save()
            
            log('Writing coverage results, this could take a moment')
            _coverage_object.html_report(directory=_coverage_directory, ignore_errors=True)

def run_python_code_on_client(python_code):
    """
    Queues a script to execute on the client
    """
    UnityServer.queue_client_func('execute', python_code)
    
def run_python_file_on_client(python_file):
    """
    Queues a file to execute on the client
    """
    UnityServer.queue_client_func('execute', 'execfile(\"%s\")'%python_file)

def call_remote_service(service_name, args):
    """
    Calls the given service in the client process, as defined by the client 
    connection service
    """
    UnityServer.queue_client_func(service_name, args)

"""
Private interface. Unity scripts should never call these functions directly
"""
class UnityServer:
    """
    Class that manages all rpyc communication aspects between Unity and its 
    client process
    """
    _rpyc_server_connection  = None
    _server_thread      = None

    _rpyc_client_connection  = None
    _client_connection_lock  = None
    _client_thread           = None
    
    # Could be removed when the TODO in start is implemented
    _client_init_module_path = None

    # Minimum amount of time (seconds) to spend processing rpyc requests when 
    # the EditorApplication.update callback gets invoked
    _dispatch_time           = 0.006
    
    # Used to tell the client thread to finish
    _finish_client_thread    = False
    
    # Function to remote execute on the client process. 
    # Tuple of (function_name,args)
    _to_execute_on_client = []
    
    @classmethod
    def start(cls, client_init_module_path):
        """ 
        Starts the Unity rpyc server and its server thread
        Installs the EditorApplication.update callback
        
        TODO: also start the client and complete handshake before returning 
              control to Unity, which means:
              - Start the server
              - Start the client process
              - Wait for the client process to connect back to server
              - Connect to client
        """
        if not cls._rpyc_server_connection:
            log('Starting server on port {} (client_init_module_path = {})'.format(polling_port, client_init_module_path))
            cls._client_init_module_path = client_init_module_path
            
            cls._rpyc_server_connection = polling_server.PollingServer(polling_server.PollingSlaveService, port=polling_port)
            polling_server.PollingServerUtil.init()
        
            cls._server_thread = threading.Thread(target = cls._rpyc_server_connection.start, name = "Unity Server")
            cls._server_thread.start()
            
            log("  started")
            
            if UnityEditor.EditorApplication.update:
                UnityEditor.EditorApplication.update = UnityEditor.EditorApplication.update.Combine(UnityEditor.EditorApplication.update,UnityEditor.EditorApplication.CallbackFunction(cls._on_application_update))
            else:
                UnityEditor.EditorApplication.update = UnityEditor.EditorApplication.CallbackFunction(cls._on_application_update)
            
        # Automatically start the client. To be improved with proper handshake
        cls.ensure_client_connection() 

    @classmethod        
    def stop(cls, terminate_client):
        # Stop the server first. The client might get exceptions which should 
        # be handled by the unity_connection
        if cls._server_thread:
            polling_server.PollingServerUtil.close()
        
            if cls._rpyc_server_connection:
                cls._rpyc_server_connection.close()
                cls._rpyc_server_connection = None
            
            log('Server stopped. Finishing server thread')
            while cls._server_thread.is_alive():
                log('  Server thread is still alive. Waiting')
                time.sleep(0.5)
           
            cls._server_thread = None
            log('  finished')

        # Deal with the client connection 
        if cls._client_thread:
            with cls._client_connection_lock:
                # Unblock the client thread if required. This will make the client
                # thread exit its loop since finish_client_thread is set to True
                log('Finishing client thread')
                cls._finish_client_thread = True
                cls._client_connection_lock.notify()
                
            log('Finishing client thread')
            while cls._client_thread.is_alive():
                log('  Client thread is still alive. Waiting')
                # Could probably use a wait/notify here
                time.sleep(0.5)
    
            log('  finished')
    
            # Notify the client process that we are leaving
            log('Notifying client process')
            try:
                cls._rpyc_client_connection.root.on_server_stop(terminate_client)
            except:
                log('  could not notify the client. The client process might already be terminated')
                
            log('Disconnecting from client')
            try:    
                cls._rpyc_client_connection.close()
                log('  disconnected')
            except:
                log('  could not disconnect from the client. The client process might already be terminated')
                
                
        cls._rpyc_client_connection = None
        cls._client_thread = None
        cls._client_connection_lock = None
        
    @staticmethod
    def _on_application_update():
        """
        Called by Unity (EditorApplication.update)
        Processes as many rpyc request as possible in a given time
        """
        start = time.time()
        while (time.time() - start) < UnityServer._dispatch_time:
            polling_server.PollingServerUtil.dispatch_data()

    @staticmethod
    def client_thread_loop():
        """ 
        This function sends requests to the client. It is ran on a separated 
        thread so we do not block the server main thread on the client
        (would easily result in deadlocks as the client is often blocked on 
        the server main thread
        """
        # start fresh
        with UnityServer._client_connection_lock:
            UnityServer._to_execute_on_client = []
            UnityServer._finish_client_thread = False
    
        log('[client_thread] Starting client_thread_loop')
        while not UnityServer._finish_client_thread:
            function_name = None
            args = None
            with UnityServer._client_connection_lock:
                if not UnityServer._to_execute_on_client:
                    # There is nothing to execute on the client process. 
                    # Wait on the main thread 
                    UnityServer._client_connection_lock.wait()
                    
                    if UnityServer._finish_client_thread:
                        break
                
                # do not keep that lock while waiting on the client. Create a copy of the data instead
                (function_name, args) = UnityServer._to_execute_on_client.pop(0)
    
            client_func = eval('UnityServer._rpyc_client_connection.root.%s'%function_name)
            if args:
                client_func(args);
            else:
                client_func();
            
        log('[client_thread] Exiting client thread')
        
    @classmethod
    def queue_client_func(cls, func, args):
        """
        Enqueues a remote function call to be executed on the client
        """
        cls.ensure_client_connection()
        with cls._client_connection_lock:
            cls._to_execute_on_client.append((func,args))
            cls._client_connection_lock.notify()            

    @classmethod
    def ensure_client_connection(cls):
        """
        Makes sure the client connection is alive and that the client is ready 
        to execute remote calls
        """
        if not cls._client_connection_lock:
            cls._client_connection_lock = threading.Condition()
        
        with cls._client_connection_lock:
            # Is the client alive?
            if not cls._rpyc_client_connection:
                # Having a running thread without a connection does not make sense.
                # Start fresh
                cls._client_thread = None
                
                log('Trying to connect to client on port {}'.format(client_port))
                try:
                    cls._rpyc_client_connection = rpyc.connect('localhost', client_port)
                    log(' connected')
                except:
                    pass
                
                if not cls._rpyc_client_connection:
                    # start the client process (will create the client rpyc server)
                    unity_client_path = System.IO.Path.GetFullPath('Packages/com.unity.scripting.python/Python/site-packages/unity_rpyc/unity_client.py');
                    unity_client_path = unity_client_path.replace('\\','/')
    
                    args = [unity_client_path]
                    if cls._client_init_module_path:
                        args.append(cls._client_init_module_path)
                    if cls.spawn_subpython(args) is None:
                        return

                    # TODO: More robust handshake:
                    #    - Popen
                    #    - Client connects to server
                    #    - Server reacts by connecting to client
                    time.sleep(1)
                    log('Connecting to client on port {}'.format(client_port))

                try:
                    cls._rpyc_client_connection= rpyc.connect('localhost', client_port)
                    log('  connected')
                except:
                    trace = traceback.format_exc()
                    log('  Unable to connect to client:%s'%trace)

                if cls._rpyc_client_connection:    
                    log('Starting client_thread')
                    cls._client_thread = threading.Thread(target = cls.client_thread_loop, name = "Unity Client Thread")
                    cls._client_thread.start()

    @classmethod
    def spawn_subpython(cls, args, logging = True):
        """
        Spawn a python subprocess.

        This is used to spawn the client, and it's used to check that the client will work.

        Returns a Popen on success, and None on failure.
        """
        args = [python_executable] + args

        # put our site-packages in the client's PYTHONPATH
        client_pythonpath = System.IO.Path.GetFullPath('Packages/com.unity.scripting.python/Python/site-packages')
        client_pythonpath = client_pythonpath.replace('\\','/')
        client_environment = dict(os.environ)
        python_paths = [ client_pythonpath ] + extra_site_packages
        if 'PYTHONPATH' in client_environment:
            python_paths.append(client_environment['PYTHONPATH'])
        client_environment['PYTHONPATH'] = os.pathsep.join(python_paths)

        # For windows, on python 2.7, ensure we only use ASCII strings.
        # os.environ/os.getenv() only returns ASCII, therefore any non-ASCII characters will either be approximated
        # or replaced with a question mark.
        # https://measureofchaos.wordpress.com/2011/03/04/python-on-windows-unicode-environment-variables/
        #
        # The problem should go away on python 3.x
        # https://stackoverflow.com/questions/12253014/why-does-popen-fail-on-windows-if-the-env-parameter-contains-a-unicode-object
        if sys.version_info.major < 3:
            client_environment = { key.encode('ascii', 'replace') : value.encode('ascii', 'replace') for key,value in client_environment.iteritems() }

        if logging:
            log('PythonNet: Creating client process: {} with PYTHONPATH={}'.format(' '.join(args), client_environment['PYTHONPATH']))
        try:
            return subprocess.Popen(args, close_fds=True, env=client_environment)
        except:
            if logging:
                exception('Could not launch the Python interpreter for the client process. Please refer to the com.unity.scripting.python documentation on how to configure Python for Unity"')
            return None
