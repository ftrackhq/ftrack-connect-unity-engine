import rpyc
import threading

class PollingServerUtil:
    """
    Utility class for applications using the rpyc polling server
    It only supports one polling server per process
    
    Applications should call init before starting the polling server
    Applications should call close before stopping the polling server
    """
    # Tuple of (connection,data)
    _data_to_dispatch = None
    
    # The synchronisation primitive (threading.Condition)
    _dispatch_lock = None
    
    # Tells the thread that the polling server is closing
    _closing = False

    @classmethod
    def init(cls):
        """
        Must be called before starting the polling server
        - Clears the data to dispatch, if any (coming from a closed server)
        - Creates a new synchronization primitive
        """
        cls._data_to_dispatch = None
        if not cls._dispatch_lock:
            cls._dispatch_lock = threading.Condition()
            
        cls._closing = False

    @classmethod
    def close(cls):
        """
        Must be called before stopping the polling server
        - Clears the data to dispatch (unprocessed data from the polling server)
        - Sets the flag that tells the thread we are closing
        """
        with cls._dispatch_lock:
            # Dispatch data one last time if present
            # This will notify the other thread and make it quit
            cls.dispatch_data()
            
            cls._data_to_dispatch = None
            cls._closing = True

    @classmethod
    def dispatch_data(cls):
        """
        The application main thread needs to periodically call dispatch_data
        This will process one request coming from the polling server
        """
        with cls._dispatch_lock:
            if cls._closing:
                # We are closing
                return

            if cls._data_to_dispatch:
                try:
                    (connection, data) = cls._data_to_dispatch
                    connection._dispatch(data)
                except EOFError:
                    print('Connection error while dispatching data. Ignoring')

                # Reset, ready for new data 
                cls._data_to_dispatch = None
            
            # Wake the blocked thread
            cls._dispatch_lock.notify()
            
    @classmethod
    def _set_data_to_dispatch_and_wait(cls, connection, data):
        """
        Called by the polling server (not the main thread) to enqueue a request
        The application should periodically call dispatch_data from the main 
        thread in order to process the queued request
        """
        with cls._dispatch_lock:
            if cls._closing:
                # We are closing
                return
            
            assert cls._data_to_dispatch is None, 'Polling server is trying to queue a request while there is an unprocessed request already queued'
            cls._data_to_dispatch = (connection, data)
            
            # Block until the main thread dispatches the data
            cls._dispatch_lock.wait()
            
class PollingServer(rpyc.utils.server.OneShotServer):
    """
    The Polling Server class
    """
    pass

class PollingConnection(rpyc.core.service.Connection):
    """
    The Polling Connection simply blocks every time it gets a dispatch request. 
    It unblocks when the request has been processed by the main thread
    """
    def _dispatch(self, data):
        """
        Override from the super class
        """
        # We got data to dispatch on a thread, it needs to be dispatched from 
        # the main thread
        PollingServerUtil._set_data_to_dispatch_and_wait(super(PollingConnection,self), data)

class PollingSlaveService(rpyc.core.service.SlaveService):
    """
    The base service. Inherits from the rpyc slave service and uses the polling connection 
    """
    _protocol = PollingConnection